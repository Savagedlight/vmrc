################################################################ LICENSE
#
# Copyright (c) 2012-2015 Michael Dexter <editor@callfortesting.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
############################################################ DEVELOPER NOTES

Latest releases are available at: https://github.com/michaeldexter/vmrc

vmrc Design Goals

* "Unix" design philosophy, simple architecture and transparent operation
* Rapid, flexible development using in-base tools
* Zero dependencies for basic operation with significant-value add-ons
* Fundamentally-portable design
* Open architecture to accept additional multiplicity strategies

While patches are welcome but please take the time to understand how this script
works before proposing solutions to problems that might be more simple or
complex than they appear. Ask questions!

vmrc aims to have zero dependencies to operate. It optionally uses external
utilities like grub2-bhyve, tmux, qemu, screen and the like to add
functionality but will hopefully never depend on them.

The vm rc script and mkvm.sh perform two key functions:

1. Programmatically construct virtual machine boot devices (mkvm.sh/"iso" mode)
2. Manage the lifecycle operation of the virtual machines it creates

A "Virtual Machine" is comprised of a directory containing a bootable disk
image, a configuration file derived from a template, a mnt/ directory for the
attachment and mounting of the disk image (FreeBSD only) and an optional
preflight script.

mkvm.sh is largely a simplified FreeBSD installer that is comprised of
preflight, primary and debug functions.

The vm rc script primarily creates bhyveload(8) and bhyve(8) command syntax for
loading and booting virtual machines based on the criteria in the configuration
files such as the VM RAM allocation, block device to boot, network interfaces
etc. The vm rc script will output the bhyveload and bhyve command strings that
it generates prior to executing them. If you copy these out, they should work
on their own along with the preflight script if included.

Each VM directory in /usr/local/vmrc/vm/ is fully self-contained and is
only referenced by the vm script looking for VMs in the vm/ directory and then
using the unique numeric VM ID number at the end of the virtual machine.

For example: vm0 has the arbitrary name of "vm" and the VM ID of "0". VMs can
share the same name (vm0, vm1, vm2) but must have a unique ID (vm0, freenas1,
openbsd3). VMs vm0 and linux0 would have conflicting VM IDs.

This naming is extended to the contents of the vm/ directory (vm/vm0/vm0.img)

The VM ID is used to generate unique, non-conflicting tap# network interfaces.

With the introduction of multiple VM virtual network devices, a new convention
was needed to keep VM tap devices unique while preserving their obvious
association with a given VM. The solution is to add a suffix to the tap device,
indicating the NIC ID (vm0's tap0 -> tap01 or vm3's tap3 ->tap31).

This revealed a problem: ifconfig will now allow for tap ID's to be
prefixed with "0" and thus vm0's tap03 would be invalid. To solve this, vmrc 
emplys a double digit VMID that is prefixed with the arbitrary "8", resulting
in vm0's fourth network interface being:

tap8033 [ 8 | VM ID of 3 | Network Device ID of 4 (counting from 0) ]

Network device "3" is the fourth device because the first one is "0".

Additional network devices could be creatd on additional PCI virtual interfaces
but this functionality is not supported by vmrc.
